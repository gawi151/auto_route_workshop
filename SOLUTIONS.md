# Workshop Solutions

This file contains solutions for all the TODO items in the workshop. Use this as a reference after you've attempted the tasks.

## Lesson 1: Basic Routing Setup

### TODO 1: Navigate to Lesson1DetailsScreen

**File:** `lib/screens/lesson1_home.dart`

**Solution:**
```dart
ElevatedButton(
  onPressed: () {
    context.router.push(Lesson1DetailsRoute());
  },
  child: const Text('Go to Details'),
),
```

**Explanation:**
- `context.router` provides access to the auto_route navigation system
- `push()` adds the new screen to the navigation stack
- `Lesson1DetailsRoute()` is the type-safe route generated by auto_route

### TODO 2: Understand pop() behavior

**File:** `lib/screens/lesson1_details.dart`

**Solution:**
```dart
ElevatedButton(
  onPressed: () {
    context.router.pop();
  },
  child: const Text('Go Back (Manual)'),
),
```

**Explanation:**
- `pop()` removes the current screen from the stack
- The back button (AppBar) automatically handles this
- You can also call it manually for custom behavior

---

## Lesson 2: Named Routes & Parameters

### TODO 1: Navigate to ProductDetailScreen with product parameter

**File:** `lib/screens/lesson2_products.dart`

**Solution:**
```dart
ProductCard(
  product: product,
  onTap: () {
    context.router.push(
      Lesson2ProductDetailRoute(product: product),
    );
  },
)
```

**Explanation:**
- The product object is passed as a parameter to the route
- The route class `Lesson2ProductDetailRoute` requires the product parameter
- This is type-safe - if you forget it or pass the wrong type, you get a compile error

### TODO 2: Display received product

**File:** `lib/screens/lesson2_product_detail.dart`

The product is already received as a constructor parameter:
```dart
final Product product;

const Lesson2ProductDetailScreen({required this.product});
```

You can use it directly in the build method (already implemented in the skeleton).

### TODO 3: Challenge - Use replace() instead of push()

**File:** `lib/screens/lesson2_product_detail.dart`

**Solution:**
```dart
OutlinedButton(
  onPressed: () {
    final nextProduct = Product.nextProduct(product);
    context.router.replace(
      Lesson2ProductDetailRoute(product: nextProduct),
    );
  },
  ...
),
```

**Explanation:**
- `replace()` replaces the current screen without adding to the stack
- Useful for navigation that shouldn't add to history
- Back button takes you back to the product list (not the previous product)
- Compare this to `push()` which would stack screens

---

## Lesson 3: Deep Linking

### TODO 1: Configure paths in app_router.dart

**File:** `lib/router/app_router.dart`

**Solution:**
```dart
// Lesson 3 Shell - Deep Linking
AutoRoute(
  page: Lesson3ShellRoute.page,
  path: "lesson3",
  children: [
    AutoRoute(path: "intro", initial: true, page: Lesson3DeepLinksRoute.page),
    AutoRoute(path: "profile", page: Lesson3ProfileRoute.page),
    AutoRoute(path: "edit-profile", page: Lesson3ProfileEditRoute.page),
    AutoRoute(path: "app-settings", page: Lesson3ProfileSettingsRoute.page),
  ],
)
```

**Explanation:**
- `path` is required for deep linking via `navigateNamed()`
- Paths are hierarchical: child paths are relative to parent
- `/lesson3/profile` navigates to the profile screen
- `/lesson3/edit-profile` navigates directly to edit
- `/lesson3/app-settings` naviates to settings
- Without paths specified path is autogenerated based on route name for example `Lesson3ShellRoute` -> `lesson3-shell-route`

### TODO 2: Implement deep link navigation using naviatePath()

**File:** `lib/screens/lesson3_deep_links.dart`

**Solution:**
The custom path input is already implemented and uses:
```dart
void _navigateToPath(String path) {
  try {
    context.router.navigatePath(path);
  } catch (e) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Invalid path: $path')),
    );
  }
}
```

**Explanation:**
- `navigatePath()` is different from `push()` - it uses URL paths
- Try-catch handles invalid paths gracefully

---

## Lesson 4: Advanced Patterns

### TODO 1: Implement guarded route navigation

**File:** `lib/screens/lesson4_settings.dart`

**Solution:**
Create a guard first (in a separate file or in the same file):

```dart
// Define a simple guard
class Lesson4AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, AutoRoutePage route) {
    // Simulate checking if user is authenticated
    bool isAuthenticated = false;
    resolver.next(isAuthenticated);
  }
}
```

Then in the route:
```dart
// In app_router.dart
AutoRoute(
  page: Lesson4ProtectedRoute.page,
  guards: [Lesson4AuthGuard()],
)
```

Navigation button:
```dart
ElevatedButton(
  onPressed: () {
    context.router.push(
      Lesson4ProtectedRoute(),
      onFailure: (failure) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $failure')),
        );
      },
    );
  },
  child: const Text('Try Protected Route'),
),
```

**Explanation:**
- Guards intercept navigation and can allow/prevent it
- `resolver.next(boolean)` allow/prevent navigation
- Guards are checked before the route completes

### TODO 2: Implement guard with data fetching example

**File:** `lib/screens/lesson4_settings.dart`

**Solution:**
```dart
class AsyncDataGuard implements AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, AutoRoutePage route) async {
    // Simulate fetching data
    await fetchData("your custom data");
    resolver.next();
  }
}

// In app_router.dart
AutoRoute(
  page: Lesson4AsyncDataRoute.page,
  guards: [AsyncDataGuard()],
)
```

Button:
```dart
ElevatedButton(
  onPressed: () async {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Loading data...'),
      ),
    );
    context.router.push(Lesson4AsyncDataRoute())
  },
  child: const Text('Load Data'),
),
```

**Explanation:**
- You can await in Guard's `onNavigation`
- The route waits for the guard to complete before navigating
- You can fetch data before entering screen

### TODO 4: Add custom page transition

**File:** `lib/screens/lesson4_settings.dart`

**Solution:**
In `app_router.dart`:

```dart
AutoRoute(
  page: Lesson4SettingsRoute.page,
  transitionsBuilder: (context, animation, secondaryAnimation, child) {
    return FadeTransition(opacity: animation, child: child);
  },
)
```

Or in the AppShellScreen for all transitions:
```dart
@RoutePage()
class AppShellScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return AutoTabsRouter(
      routes: [...],
      transitionBuilder: (context, child, animation) {
        return FadeTransition(opacity: animation, child: child);
      },
      builder: (context, child) {
        return Scaffold(
          body: child,
          bottomNavigationBar: BottomNavigationBar(...),
        );
      },
    );
  }
}
```

**Common Transitions:**

```dart
// Fade transition
FadeTransition(opacity: animation, child: child)

// Scale transition
ScaleTransition(scale: animation, child: child)

// Slide transition
SlideTransition(
  position: Tween<Offset>(
    begin: const Offset(1, 0),
    end: Offset.zero,
  ).animate(animation),
  child: child,
)

// Custom animation
CustomTransition(
  animation: animation,
  secondaryAnimation: secondaryAnimation,
  child: child,
)
```

**Explanation:**
- Transitions control how screens appear/disappear
- `animation` is the primary animation (entering screen)
- `secondaryAnimation` is for the screen being covered
- Use common widgets like `FadeTransition`, `ScaleTransition`

---

## Key Takeaways

### Lesson 1
- `push()` adds to stack
- `pop()` removes from stack

### Lesson 2
- Parameters are type-safe
- Compiler catches parameter errors
- Better than string-based routing

### Lesson 3
- Deep linking
- Defining paths
- `navigatePath(path)` to deep link

### Lesson 4
- Guards prevent navigation
- Resolvers pre-fetch data
- Transitions customize appearance

---

## Testing Your Solutions

For each lesson:
1. Implement the TODO
2. Run `flutter pub run build_runner build` if needed
3. Run `flutter run`
4. Test the behavior
5. Navigate between tabs to verify isolation
6. Try back buttons and manual navigation

## Common Issues While Implementing

**"Route not found"**
- Did you generate routes with build_runner?

**"Parameter missing"**
- Did you pass all required parameters?

**"Stack doesn't work as expected"**
- Are you using the right navigation method?
- `push` vs `replace` behaves differently

**"Transition not showing"**
- Is the transition builder registered in app_router.dart?
- Check the route configuration

---

Happy learning! If you get stuck, compare your implementation to these solutions.
